# C++ Ass2 测试框架

使用方式：

将你的代码文件 *assign2.cpp* 复制到该目录下，并在该目录下运行该命令：

```shell
g++ -std=c++20 test.cpp assign2.cpp -o test.out && ./test.out 
```

便可执行该测试。



---

由于这个框架是一拍脑子写的，可能有点凌乱。

下面是该框架所遵守的约定：

- 当你通过堆内存构建生命周期不便控制的 tree_node 的结点时，应当使用 `new tree_node` 进行对象的创建。其它方法都不应当使用：使用 `malloc` 和 `placement new` 都会破坏该框架对 `tree_node` 对象的监视能力，导致对代码的正确性发生错误判断；使用 `new tree_node[]` 构建对象数组在本框架当前版本同样被禁止。
  本框架能够回收满足该约定的所有内存泄漏，并中止错误的 `delete` 方法运行。
- 在你的 `assign2` 实现方法中不应当出现未 handle 的异常控制，或 throw 出不继承自 `std::exception` 的异常。特别强调，不应当使用 `std::string` 作为异常的类型——因为我的框架已经用了它了。
  否则其造成的程序测试分析错误我不负责。



---

由于本框架原本只是作为一个实验性玩具，所以测试内容还有待补充。

下面是对开发者的讲解：

你只需要在文件 `test.hpp` 中补充你的测试单元，既可在运行中看到它。

操作如下：

在最后的代码 （见下文）上面填写你的模版方法 `r_type test<__COUNTER__>()` 的内容，便可看见它的运行结果。

```C++
namespace {
	constexpr int test_number {__COUNTER}; 
}
```



你可以观察我写的各测试 demo 来获得更多的启发。

请不要在其它任何一个地方再次用到 MACRO `__COUNTER__`. 

关于返回值，如果本次测试没有异常，建议使用 `return {};` 表示测试通过。

值得注意的是，即使程序执行到 `return {};`，程序并非就一定会汇报测试通过——它会在这之后进行内存泄漏的相关检查！

而当你显式认为本次测试有失败，你希望给出一点错误的信息汇报，你可能通过 `return "错误信息"` 来达成你的目标。



---

以下是对错误信息汇报的更详细说明：

- 当程序出现禁止的代码调用（`new tree_node[]`, repeatedly `delete` a `tree_node`, 或 `delete[] tree_node` 操作），框架会退出本次测试方法的执行并回报相关的测试信息作为提示——这往往是由于错误的测试代码造成的，而不是错误的库代码！请慎重编写测试代码！
- 当程序正常执行 `test` 方法完毕，将会获得其返回值（`std::string` 类型）。若返回值不为空，则回报其返回值作为错误原因。注意，使用 `return {};` 来描述该 `test` 方法的正确执行，而不是使用 `return "";`. 
- 当程序有内存泄漏的情形发生时，即对于 `tree_node` 在堆空间的开辟的所有内存空间没有在本次 `test` 方法结束前全部释放，则判定为内存泄漏。`BST` 则不纳入内存泄漏的监控范围。（因为懒

**错误信息的汇报优先级从上至下递减。**

测试程序不会一次性汇报多个错误。



---

尽管我尝试了很多办法，但似乎 C++ 的程式没有符合标准、通用的语法能够让其从 `segmentation fault` 错误中恢复。

如果可以，我希望有能人能为该测试框架加上对该错误的正确处理。

由于暂时不能处理该问题，所以测试者需要严格留意测试过程中自己的代码是否有不经空指针检验就直接访问对应的对象成员的情形。

请加上严格的测试条件，以避免测试程序不能完全执行完毕。

此外，你可以选择在自己的实现（也就是  `assign2.cpp` ）中在面对难以处理的情形下——将一个 `std::string`  丢出以获得本框架的支持。

**这不太好，但我允许你这么做。**

我会在一个 test example 中写一段示范代码来展示这个特性。

或者参考下面这段语法：（我希望丢出的内容是：今天阳光灿烂。）

```C++
throw std::string {"今天阳光灿烂"}; 
```



---

新版更新！

<div align="right">Sat Apr 2 10:32:03 CST 2022</div>

于本机平台框架能从 segmentation fault 中恢复了！

本机所用的编译器版本：

```
Apple clang version 13.1.6 (clang-1316.0.21.2)
Target: arm64-apple-darwin21.4.0
Thread model: posix
```



其它平台有待测试。



---

新的支持加入：

- 对于继承自 `std::exception` 的异常，本框架能够将其捕获并输出其造成错误的原因。



由于新支持的加入，我给出以下的测试代码、实现代码的建议。

在测试代码中，你可以使用 `throw std::string` 和 `throw std::runtime_error` 等方式进行异常的抛出处理。

但你应只使用 `catch std::runtime_error` 处理后一种异常（如果你喜欢），前一种异常原则上你不允许尝试捕获（但其实你可以转发它）。

由于异常抛出会导致代码执行顺序的错乱，建议请不要使用 `new` 语句进行 `BST` 对象的创建，而是直接在栈上构建。

示例代码：

```C++
template <> 
r_type test<__COUNTER__>() {
  BST bst {}; // 使用 {} 指示编译器对其进行强制初始化。
  
  tree_node *t; 
  auto error_code = inserted_into_BST(&bst, 520, &t); 
  
  // 执行你的测试代码，例如
  if (error_code == 0) 
    return "成功在没有初始化比较器的二叉搜索树上插入新节点。"; 
 	// ... 
}
```



---

Author: Cutie Deng

Mail: Dengzr2020@mail.sustech.edu.cn

欢迎致信询问更多内容。