# C++ Ass2 测试框架

使用方式：

将你的代码文件 *assign2.cpp* 复制到该目录下，并在该目录下运行该命令：

```shell
g++ -std=c++20 test.cpp assign2.cpp -o test.out && ./test.out 
```

便可执行该测试。



---

由于这个框架是一拍脑子写的，可能有点凌乱。

下面是该框架所遵守的约定：

- 当你通过堆内存构建生命周期不便控制的 tree_node 的结点是，应当使用 `new tree_node` 进行对象的创建。其它方法都不应当使用：使用 `malloc` 和 `placement new` 都会破坏该框架对 `tree_node` 对象的监视能力，导致对代码的正确性发生错误判断；使用 `new tree_node[]` 构建对象数组在本框架当前版本同样被禁止。
  本框架能够回收满足该约定的所有内存泄漏，并中止错误的 `delete` 方法运行。
- 在你的方法中不应当出现未 handle 的异常控制，或 handle 不继承自 `std::exception` 的异常。特别强调，不应当使用 `std::string` 作为异常的类型——因为我的框架已经用了它了。
  否则造成的程序测试分析错误我不负责。



---

由于本框架原本只是作为一个实验性玩具，所以测试内容还有待补充。

下面是对开发者的讲解：

你只需要在文件 `test.hpp` 中补充你的测试单元，既可在运行中看到它。

操作如下：

在最后的代码 （见下文）上面填写你的模版方法 `r_type test<__COUNTER__>()` 的内容，便可看见它的运行结果。

```C++
namespace {
	constexpr int test_number {__COUNTER}; 
}
```



你可以观察我写的各测试 demo 来获得更多的启发。

请不要在其它任何一个地方再次用到 MACRO `__COUNTER__`. 

关于返回值，如果本次测试没有异常，建议使用 `return {};` 表示测试通过。

值得注意的是，即使程序执行到 `return {};`，程序并非就一定会汇报测试通过——它会在这之后进行内存泄漏的相关检查！

而当你显示认为本次测试有失败，你希望给出一点错误的信息汇报，你可能通过 `return "错误信息"` 来达成你的目标。



---

Author: Cutie Deng

Mail: Dengzr2020@mail.sustech.edu.cn

欢迎致信询问更多内容。